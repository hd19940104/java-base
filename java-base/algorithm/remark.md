###mysql
```
1、索引相关：
```
```
1、B树

B树是一种自平衡的搜索树，形式很简单：
（1）多路，非二叉树

（2）每个节点既保存索引，又保存数据

（3）搜索时相当于二分查找

```
```
2、B+树
（1）多路非二叉

（2）只有叶子节点保存数据

（3）搜索时相当于二分查找

（4）增加了相邻接点的指向指针。

```
```
3、B树和B+树的区别

（1）B+树查询时间复杂度固定是logn，B树查询复杂度最好是 O(1)。

（2）B+树相邻接点的指针可以大大增加区间访问性，可使用在范围查询等，而B-树每个节点 key 和 data 在一起，则无法区间查找。

（3）B+树更适合外部存储，也就是磁盘存储。由于内节点无 data 域，每个节点能索引的范围更大更精确

（4）注意这个区别相当重要，是基于（1）（2）（3）的，B树每个节点即保存数据又保存索引，所以磁盘IO的次数很少，B+树只有叶子节点保存，磁盘IO多，但是区间访问比较好。
```
```
4、聚簇索引和主键索引

聚簇索引的优缺点
　　优点：
　　　　1.数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快
　　　　2.聚簇索引对于主键的排序查找和范围查找速度非常快
　　缺点：
　　　　1.插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键
　　　　2.更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般【定义主键为不可更新】。
　　　　3.二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。

辅助索引（非聚簇索引）
　　在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找。
辅助索引叶子节点存储的不再是行的物理位置，而是主键值。通过辅助索引首先找到的是主键值，再通过主键值找到数据行的数据页，再通过数据页中的Page Directory找到数据行。
　　Innodb辅助索引的叶子节点并不包含行记录的全部数据，叶子节点除了包含键值外，还包含了相应行数据的聚簇索引键。
　　辅助索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个辅助索引。在innodb中有时也称辅助索引为二级索引。
对于Innodb，主键毫无疑问是一个聚集索引。但是当一个表没有主键，或者没有一个索引，Innodb会如何处理呢。请看如下规则：

       1.如果一个主键被定义了，那么这个主键就是作为聚集索引

       2. 如果没有主键被定义，那么该表的第一个唯一非空索引被作为聚集索引

       3. 如果没有主键也没有合适的唯一索引，那么innodb内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键是一个6个字节的列，改列的值会随着数据的插入自增。

       4.自增主键会把数据自动向后插入，避免了插入过程中的聚集索引排序问题。聚集索引的排序，必然会带来大范围的数据的物理移动，这里面带来的磁盘IO性能损耗是非常大的。 而如果聚集索引上的值可以改动的话，那么也会触发物理磁盘上的移动，于是就可能出现page分裂，表碎片横生。所以不应该修改聚集索引。


```
5、索引失效
```
1. 随着表的增长，where条件出来的数据太多，大于15%，使得索引失效（会导致CBO计算走索引花费大于走全表）

2. 统计信息失效      需要重新搜集统计信息

3. 索引本身失效      需要重建索引

下面是一些不会使用到索引的原因

索引失效 
1) 没有查询条件，或者查询条件没有建立索引 
2) 在查询条件上没有使用引导列 
3) 查询的数量是大表的大部分，应该是30％以上。 
4) 索引本身失效 
5) 查询条件使用函数在索引列上（见12） 
6) 对小表查询 
7) 提示不使用索引 
8) 统计数据不真实 
9) CBO计算走索引花费过大的情况。其实也包含了上面的情况，这里指的是表占有的block要比索引小。 
10)隐式转换导致索引失效.这一点应当引起重视.也是开发中经常会犯的错误. 由于表的字段tu_mdn定义为varchar2(20), 
但在查询时把该字段作为number类型以where条件传给Oracle,这样会导致索引失效. 
错误的例子：select * from test where tu_mdn=13333333333; 
正确的例子：select * from test where tu_mdn='13333333333'; 
11)对索引列进行运算导致索引失效,我所指的对索引列进行运算包括(+，-，*，/，! 等) 
错误的例子：select * from test where id-1=9; 
正确的例子：select * from test where id=10; 
12)使用Oracle内部函数导致索引失效.对于这样情况应当创建基于函数的索引. 
错误的例子：select * from test where round(id)=10; 
说明，此时id的索引已经不起作用了 正确的例子：首先建立函数索引， 
create index test_id_fbi_idx on test(round(id)); 
然后 select * from test where round(id)=10; 这时函数索引起作用了 1,<> 2,单独的>,<,(有时会用到，有时不会) 
3,like "%_" 百分号在前. 
4,表没分析. 
5,单独引用复合索引里非第一位置的索引列. 
6,字符型字段为数字时在where条件里不添加引号. 
7,对索引列进行运算.需要建立函数索引. 
8,not in ,not exist. 
9,当变量采用的是times变量，而表的字段采用的是date变量时.或相反情况。 
10, 索引失效。 
11,基于cost成本分析(oracle因为走全表成本会更小)：查询小表,或者返回值大概在10%以上 
12,有时都考虑到了 但就是不走索引,drop了从建试试在 
13,B-tree索引 is null不会走,is not null会走,位图索引 is null,is not null 都会走 
14,联合索引 is not null 只要在建立的索引列（不分先后）都会走, 
in null时 必须要和建立索引第一列一起使用,当建立索引第一位置条件是is null 时, 
其他建立索引的列可以是is null（但必须在所有列 都满足is null的时候）, 
或者=一个值；当建立索引的第一位置是=一个值时,其他索引列可以是任何情况（包括is null =一个值）, 
以上两种情况索引都会走。其他情况不会走。
```
6、expain
```
概要描述：
id:选择标识符
select_type:表示查询的类型。
table:输出结果集的表
partitions:匹配的分区
type:表示表的连接类型
possible_keys:表示查询时，可能使用的索引
key:表示实际使用的索引
key_len:索引字段的长度
ref:列与索引的比较
rows:扫描出的行数(估算的行数)
filtered:按表条件过滤的行百分比
Extra:执行情况的描述和说明
```

7、Spring 生命周期
```
1\beanFactoryPostProcessor
2\beanPostProcessor
3\InstantiationAwareBeanPostProcessorAdepter

```

8、spring 事物传播机制
```
1) requied（默认属性）
如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务
2) mandatory 
支持当前事务，如果当前没有事务，就抛出异常。 
3) never
以非事务方式执行，如果当前存在事务，则抛出异常。 
4) not_supported 
以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 
5) requireds_new
新建事务，如果当前存在事务，把当前事务挂起。 
6) supports
支持当前事务，如果当前没有事务，就以非事务方式执行。 
7) nested
支持当前事务，新增Savepoint点，与当前事务同步提交或回滚。 

```